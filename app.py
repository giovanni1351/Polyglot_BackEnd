#!/usr/bin/env python3
import contextlib as __scriptmerge_contextlib


@__scriptmerge_contextlib.contextmanager
def __scriptmerge_temporary_dir():
    import tempfile
    import shutil

    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)


with __scriptmerge_temporary_dir() as __scriptmerge_working_dir:

    def __scriptmerge_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __scriptmerge_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__scriptmerge_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __scriptmerge_sys

    __scriptmerge_sys.path.insert(0, __scriptmerge_working_dir)
    __scriptmerge_write_module('core/__init__.py', b'')
    __scriptmerge_write_module('core/database.py', b'"""\n# Exemplo de como adicionar um modelo utilizando o SQLModel\n```python\nfrom database import SessionDep, engine\n\nwith SessionDep(engine) as session:\n    session.add(modelo)\n    session.commit()\n    session.refresh(modelo)\n```\n\n"""\n\nfrom collections.abc import AsyncGenerator\nfrom typing import Annotated, Any\n\nfrom astrapy import AsyncDatabase, DataAPIClient\nfrom beanie import init_beanie  # type: ignore\nfrom fastapi import Depends\nfrom pymongo import AsyncMongoClient\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom schemas.compras import criar_compras\nfrom schemas.payment_methods import Pagamento  # type: ignore # noqa: F401\nfrom schemas.products import Product\nfrom settings import SETTINGS\n\nasync_engine: AsyncEngine = create_async_engine(\n    f"postgresql+asyncpg://{SETTINGS.DB_USER}:{SETTINGS.PASSWORD}@{SETTINGS.SERVER}:{SETTINGS.PORT}/{SETTINGS.DATABASE}"\n    if not SETTINGS.RELOAD\n    else "sqlite+aiosqlite:///database.db",\n    pool_recycle=450,\n)\n\nCassandra_db: AsyncDatabase | None = None\n\n\nasync def get_async_session() -> AsyncGenerator[Any, AsyncSession]:\n    async with AsyncSession(async_engine, expire_on_commit=False) as session:\n        yield session\n\n\nasync def get_cassandra_session() -> AsyncGenerator[Any, AsyncDatabase]:\n    client = DataAPIClient(\n        SETTINGS.ASTRA_TOKEN if SETTINGS.ASTRA_TOKEN is not None else ""\n    )\n    yield client.get_async_database_by_api_endpoint(\n        SETTINGS.ASTRA_ENDPOINT if SETTINGS.ASTRA_ENDPOINT is not None else "",\n        keyspace="Polyglot",\n    )\n\n\nasync def create_db_and_tables() -> None:\n    client = AsyncMongoClient(  # type: ignore\n        "mongodb+srv://mongo:mongo@6o-semedtre.fpkb99x.mongodb.net/"\n        "?retryWrites=true&w=majority&appName=6o-semedtre"\n    )\n    await init_beanie(database=client.projeto, document_models=[Product])  # type: ignore\n\n    async with async_engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n\n\nAsyncSessionDep = Annotated[AsyncSession, Depends(get_async_session)]\nCassandraSessionDep = Annotated[AsyncDatabase, Depends(get_cassandra_session)]\n\n\nasync def init_astra_cassandra() -> None:\n    global Cassandra_db\n    # Initialize the client\n    client = DataAPIClient(\n        SETTINGS.ASTRA_TOKEN if SETTINGS.ASTRA_TOKEN is not None else ""\n    )\n    Cassandra_db = client.get_async_database_by_api_endpoint(\n        SETTINGS.ASTRA_ENDPOINT if SETTINGS.ASTRA_ENDPOINT is not None else "",\n        keyspace="Polyglot",\n    )\n\n    print("Connected to Astra DB", Cassandra_db)\n    Cassandra_db.get_collection("compras")\n    await criar_compras(Cassandra_db)\n')
    __scriptmerge_write_module('schemas/__init__.py', b'')
    __scriptmerge_write_module('schemas/compras.py', b'from datetime import datetime\n\nfrom astrapy import AsyncDatabase\nfrom astrapy.info import ColumnType, CreateTableDefinition\nfrom pydantic import BaseModel\n\n\nasync def criar_compras(cassadra_db: AsyncDatabase) -> None:\n    try:\n        cassadra_db.get_table("compras")\n        print("Tabela \'compras\' j\xc3\xa1 existe, pulando cria\xc3\xa7\xc3\xa3o")\n        return\n    except Exception:\n        print("Tabela \'compras\' n\xc3\xa3o existe, criando...")\n\n    await cassadra_db.create_table(\n        name="compras",\n        definition=CreateTableDefinition.builder()\n        .add_column("user_id", ColumnType.INT)\n        .add_column("quantidade", ColumnType.INT)\n        .add_column("product_id", ColumnType.TEXT)\n        .add_column("data_compra", ColumnType.TIMESTAMP)\n        .add_column("valor_pago", ColumnType.DECIMAL)\n        .add_column("valor_produto", ColumnType.DECIMAL)\n        .add_partition_by(["user_id"])\n        .build(),\n    )\n\n\nclass Compras(BaseModel):\n    user_id: int\n    product_id: str\n    quantidade: int\n    data_compra: datetime\n    valor_pago: float\n    valor_produto: float\n')
    __scriptmerge_write_module('schemas/payment_methods.py', b'from datetime import datetime\n\nfrom sqlmodel import Field, Relationship, SQLModel\n\nfrom schemas.user import User, UserPublic\n\n\nclass PagamentoCreate(SQLModel):\n    user_id: int\n    numero_cartao: str\n    nome_titular: str\n    data_validade: datetime\n    cod_seguranca: int\n\n\nclass Pagamento(PagamentoCreate, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    numero_cartao: str = Field(unique=True)\n    user_id: int = Field(default=None, foreign_key="user.id")\n    user: User = Relationship(back_populates="pagamentos")\n    created_at: datetime = Field(default=datetime.now())\n    updated_at: datetime | None = Field(default=None)\n\n\nclass PagamentoPublic(PagamentoCreate):\n    id: int | None\n    numero_cartao: str\n    user_id: int\n    created_at: datetime\n    updated_at: datetime | None\n\n\nclass PagamentoWithRelations(PagamentoPublic):\n    user: UserPublic\n')
    __scriptmerge_write_module('schemas/user.py', b'from datetime import datetime\nfrom typing import TYPE_CHECKING\n\nfrom sqlmodel import Field, Relationship, SQLModel\n\nif TYPE_CHECKING:\n    from schemas.payment_methods import Pagamento, PagamentoPublic\n\n\nclass UserCreate(SQLModel):\n    name: str\n    username: str = Field(unique=True)\n    email: str\n    age: int\n    cpf: str\n    password: str\n    endereco: str\n\n\nclass User(UserCreate, table=True):\n    id: int | None = Field(primary_key=True)\n    is_admin: bool = Field(default=False)\n    pagamentos: list["Pagamento"] = Relationship(back_populates="user")\n    created_at: datetime = Field(default=datetime.now())\n    updated_at: datetime | None = Field(default=None)\n\n\nclass UserPublic(UserCreate):\n    id: int | None\n    is_admin: bool\n    created_at: datetime\n    updated_at: datetime | None\n\n\nclass UserWithRelations(UserPublic):\n    pagamentos: list["PagamentoPublic"] | None\n')
    __scriptmerge_write_module('schemas/products.py', b'from datetime import datetime\nfrom typing import Annotated\n\nfrom beanie import Document, Indexed  # type: ignore\nfrom pydantic import BaseModel, Field\n\n\nclass ProductCreate(BaseModel):\n    nome: str\n    preco: float\n    marca: str\n    desc: str | None\n    product_id: str\n    created_at: datetime = Field(default=datetime.now())\n\n\nclass Product(Document):\n    owner_id: int\n    nome: str\n    preco: float\n    marca: str\n    desc: str | None\n    created_at: datetime = Field(default=datetime.now())\n    product_id: Annotated[str, Indexed(unique=True)]\n    updated_at: datetime | None = None\n')
    __scriptmerge_write_module('settings.py', b'from dotenv import load_dotenv\nfrom pydantic_settings import BaseSettings\n\nload_dotenv()\n\n\nclass Settings(BaseSettings):\n    # model_config = SettingsConfigDict(env_file="../.env", env_file_encoding="utf-8")\n\n    SERVER: str | None\n    DATABASE: str | None\n    DB_USER: str | None\n    PASSWORD: str | None\n    PORT: str | None\n    SECRET_KEY: str | None\n    LOG_LEVEL: str\n    RELOAD: bool\n    ALGORITHM: str | None\n    ACCESS_TOKEN_EXPIRE_MINUTES: int\n    KEY_PEM: str | None\n    ASTRA_TOKEN: str | None\n    ASTRA_ENDPOINT: str | None\n    ASTRA_CLIENTE_ID: str | None\n    CERT_PEM: str | None\n\n\nSETTINGS = Settings()  # type: ignore\n')
    __scriptmerge_write_module('routes/__init__.py', b'')
    __scriptmerge_write_module('routes/compras.py', b'import datetime\nfrom collections.abc import Iterable\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends\n\nfrom core.auth import get_current_user\nfrom core.database import CassandraSessionDep\nfrom schemas.compras import Compras\nfrom schemas.user import User\n\nrouter = APIRouter(prefix="/compras", tags=["compras", "vendas"])\n\n\n@router.post("/")\nasync def create_compra(\n    compra: Compras,\n    current_user: Annotated[User, Depends(get_current_user)],\n    cassandra_db: CassandraSessionDep,\n) -> Compras:\n    tabela = cassandra_db.get_table("compras")\n    resultado = await tabela.insert_one(compra.model_dump())\n    print(resultado)\n    return compra\n\n\n@router.get("/{user_id}")\nasync def get_compras(\n    user_id: int,\n    current_user: Annotated[User, Depends(get_current_user)],\n    cassandra_db: CassandraSessionDep,\n) -> list[Compras]:\n    table = cassandra_db.get_table("compras")\n    result: Iterable[Compras] | object = await table.find(\n        {"$and": [{"user_id": user_id}]}\n    ).to_list()\n    for resultado in result:\n        print(resultado)\n        resultado["data_compra"] = resultado["data_compra"].to_datetime(tz=datetime.UTC)\n        print(Compras(**resultado))\n\n    return result\n')
    __scriptmerge_write_module('core/auth.py', b'from datetime import UTC, datetime, timedelta\nfrom typing import Annotated, Any, Literal\n\nimport jwt\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jwt import InvalidTokenError\nfrom passlib.context import CryptContext\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom core.database import AsyncSessionDep\nfrom schemas.token import TokenData\nfrom schemas.user import User\nfrom settings import SETTINGS\n\nSECRET_KEY = SETTINGS.SECRET_KEY\nALGORITHM = SETTINGS.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = SETTINGS.ACCESS_TOKEN_EXPIRE_MINUTES\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")\npwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")\n\n\nasync def get_current_user(\n    token: Annotated[str, Depends(oauth2_scheme)], session: AsyncSessionDep\n) -> User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail="Could not validate credentials",\n        headers={"WWW-Authenticate": "Bearer"},\n    )\n    try:\n        payload = jwt.decode(  # type: ignore\n            token,\n            SETTINGS.SECRET_KEY,  # type: ignore\n            algorithms=[SETTINGS.ALGORITHM],  # type: ignore\n        )\n        email = payload.get("sub")\n        if email is None:\n            raise credentials_exception\n        token_data = TokenData(email=email)\n    except InvalidTokenError as e:\n        raise credentials_exception from e\n    user = (\n        await session.exec(select(User).where(User.email == token_data.email))\n    ).first()\n    if user is None:\n        raise credentials_exception\n    return user\n\n\nasync def get_current_admin(\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> User:\n    if not current_user.is_admin:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED, detail="User not admin"\n        )\n    return current_user\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\nasync def authenticate_user(\n    username: str, password: str, session: AsyncSession\n) -> User | Literal[False]:\n    user = (await session.exec(select(User).where(User.username == username))).first()\n    if not user:\n        return False\n    if not verify_password(password, user.password):\n        return False\n    return user\n\n\ndef create_access_token(\n    data: dict[str, Any], expires_delta: timedelta | None = None\n) -> str:\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(UTC) + expires_delta\n    else:\n        expire = datetime.now(UTC) + timedelta(minutes=15)\n    to_encode.update({"exp": expire})  # type: ignore\n    return jwt.encode(to_encode, SETTINGS.SECRET_KEY, algorithm=SETTINGS.ALGORITHM)  # type: ignore\n')
    __scriptmerge_write_module('schemas/token.py', b'from pydantic import BaseModel\n\n\nclass Token(BaseModel):\n    """\n    Schema para o token\n    """\n\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    email: str | None = None\n')
    __scriptmerge_write_module('routes/payment_methods.py', b'from typing import TYPE_CHECKING, Annotated\n\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import selectinload\nfrom sqlmodel import select\n\nfrom core.auth import get_current_admin\nfrom core.database import AsyncSessionDep\nfrom schemas.payment_methods import Pagamento, PagamentoCreate, PagamentoWithRelations\nfrom schemas.user import User\nfrom utils.relational_utils import create_item, get_item_or_404\n\nif TYPE_CHECKING:\n    from sqlalchemy import ScalarResult\n\nrouter = APIRouter(prefix="/payment_method", tags=["payment_method"])\n\n\n@router.post("/")\nasync def create_payment(\n    metodo: PagamentoCreate,\n    current_user: Annotated[User, Depends(get_current_admin)],\n    session: AsyncSessionDep,\n) -> Pagamento:\n    await get_item_or_404(session, User, metodo.user_id)\n    metodo.data_validade = metodo.data_validade.replace(tzinfo=None)\n    pagamento = Pagamento(**metodo.model_dump())\n    return await create_item(session, Pagamento, pagamento.model_dump())\n\n\n@router.get("/", response_model=list[PagamentoWithRelations])\nasync def get_payments(\n    current_user: Annotated[User, Depends(get_current_admin)],\n    session: AsyncSessionDep,\n) -> list[PagamentoWithRelations]:\n    lista: ScalarResult[Pagamento] = (  # type: ignore\n        await session.exec(select(Pagamento).options(selectinload(Pagamento.user)))  # type: ignore\n    ).all()  # type: ignore\n    return lista  # type: ignore\n')
    __scriptmerge_write_module('utils/__init__.py', b'')
    __scriptmerge_write_module('utils/relational_utils.py', b'from collections.abc import Sequence\nfrom datetime import datetime\nfrom typing import Any\n\nfrom fastapi import HTTPException, status\nfrom sqlmodel import SQLModel, select\n\nfrom core.database import AsyncSession, AsyncSessionDep\n\n# Decorator para logar o retorno da fun\xc3\xa7\xc3\xa3o e verificar se ocorreu algum erro\n\n\nasync def create_item[T](\n    session: AsyncSession, model: type[T], data: dict[str, Any]\n) -> T:\n    """Helper gen\xc3\xa9rico para criar"""\n    if hasattr(model, "created_at"):\n        data["created_at"] = datetime.now()\n    if hasattr(model, "updated_at"):\n        data["updated_at"] = datetime.now()\n\n    item: T = model(**data)\n    session.add(item)\n    await session.commit()\n    await session.refresh(item)\n    return item\n\n\nasync def get_item_or_404[T](\n    session: AsyncSession, model: type[T], item_id: int | float | str\n) -> T | None:\n    """Helper gen\xc3\xa9rico para buscar"""\n    item = await session.get(model, item_id)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    return item\n\n\nasync def update_item[T](\n    session: AsyncSessionDep, model: type[T], data: dict[str, Any]\n) -> T | None:\n    item = await get_item_or_404(session, model, data["id"])\n    for key, value in data.items():\n        setattr(item, key, value)\n    session.add(item)\n    await session.commit()\n    await session.refresh(item)\n    return item\n\n\nasync def get_all_items[T](\n    session: AsyncSession, model: type[T], **kwargs: dict[Any, Any]\n) -> Sequence[T] | None:\n    """Helper gen\xc3\xa9rico para buscar todos os itens"""\n    query = select(model)\n    for key, value in kwargs.items():\n        query = query.where(getattr(model, key) == value)\n    result = await session.exec(query)\n    return result.all()\n\n\nasync def delete_item[T](\n    session: AsyncSession, model: type[T], item_id: int | str | float\n) -> None:\n    """Helper gen\xc3\xa9rico para deletar"""\n    item = await session.get(model, item_id)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    await session.delete(item)\n    await session.commit()\n\n\nasync def soft_delete_item[T: SQLModel](\n    session: AsyncSession, model: type[T], item_id: int | str\n) -> None:\n    """Helper gen\xc3\xa9rico para deletar"""\n    item = await session.get(model, item_id)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    item.deleted_at = datetime.now()\n    session.add(item)\n    await session.commit()\n\n\nasync def get_all_itens_by_in_clause[T: SQLModel](\n    session: AsyncSession, model: type[T], column: str, ids: list[int]\n) -> Sequence[T]:\n    """Helper gen\xc3\xa9rico para buscar todos os ids"""\n    query = select(model)\n    query = query.where(getattr(model, column).in_(ids))\n    result = await session.exec(query)\n    return result.all()\n\n\nasync def remove_item_from_link_table[T: SQLModel](\n    session: AsyncSession, model: type[T], item_ids: list[int]\n) -> T:\n    """Helper gen\xc3\xa9rico para deletar"""\n    item = await session.get(model, item_ids)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    await session.delete(item)\n    await session.commit()\n    return item\n')
    __scriptmerge_write_module('routes/products.py', b'from typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom pymongo.errors import DuplicateKeyError\n\nfrom core.auth import get_current_user\nfrom schemas.products import Product, ProductCreate\nfrom schemas.user import User\n\nrouter = APIRouter(prefix="/products", tags=["products"])\n\n\n@router.post("/")\nasync def create_product(\n    product: ProductCreate, current_user: Annotated[User, Depends(get_current_user)]\n) -> Product:\n    produto = Product(\n        **product.model_dump(),\n        owner_id=current_user.id if current_user.id is not None else -1,\n    )\n    try:\n        await produto.insert()\n    except DuplicateKeyError as e:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT, detail="Produto ja existente"\n        ) from e\n\n    return produto\n\n\n@router.get("/")\nasync def get_products(\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[Product]:\n    produtos = Product.find()\n    return await produtos.to_list()\n\n\n@router.get("/{product_id}")\nasync def get_product(\n    product_id: str, current_user: Annotated[User, Depends(get_current_user)]\n) -> Product:\n    produto = await Product.find_one({"product_id": product_id})\n    if produto is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="Product not found by product id",\n        )\n    return produto\n')
    __scriptmerge_write_module('routes/token.py', b'from datetime import timedelta\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nfrom core.auth import authenticate_user, create_access_token\nfrom core.database import AsyncSessionDep\nfrom schemas.token import Token\nfrom settings import SETTINGS\n\nrouter = APIRouter(prefix="/token", tags=["token"])\n\n\n@router.post("/")\nasync def login_for_access_token(\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()], session: AsyncSessionDep\n) -> Token:\n    user = await authenticate_user(form_data.username, form_data.password, session)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Incorrect username or password",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n    access_token_expires = timedelta(minutes=SETTINGS.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\n            "sub": user.email,\n        },\n        expires_delta=access_token_expires,\n    )\n    return Token(access_token=access_token, token_type="bearer")  # noqa: S106\n')
    __scriptmerge_write_module('routes/user.py', b'from typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import selectinload\nfrom sqlmodel import select\n\nfrom core.auth import get_current_user, get_password_hash\nfrom core.database import AsyncSessionDep\nfrom schemas.payment_methods import Pagamento, PagamentoCreate\nfrom schemas.user import User, UserCreate, UserWithRelations\nfrom utils.relational_utils import create_item\n\nrouter = APIRouter(prefix="/user", tags=["user"])\n\n\nclass UserRegisterError(Exception): ...\n\n\n@router.post("/")\nasync def create_user(user: UserCreate, session: AsyncSessionDep) -> User:\n    user.password = get_password_hash(user.password)\n    user_exist: User | None = (\n        await session.exec(select(User).where(User.username == user.username))\n    ).first()\n    if user_exist is not None:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT, detail="Username already registred"\n        )\n    return await create_item(session, User, user.model_dump())\n\n\n@router.get("/me/")\nasync def read_users_me(\n    current_user: Annotated[User, Depends(get_current_user)], session: AsyncSessionDep\n) -> UserWithRelations:\n    user: User | None = (\n        await session.exec(\n            select(User)\n            .options(selectinload(User.pagamentos))  # type: ignore\n            .where(User.id == current_user.id)\n        )\n    ).first()\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="User n\xc3\xa3o encontrado",\n        )\n    return user  # type: ignore\n\n\n@router.post("/payment_method")\nasync def create_payment(\n    metodo: PagamentoCreate,\n    current_user: Annotated[User, Depends(get_current_user)],\n    session: AsyncSessionDep,\n) -> Pagamento:\n    metodo.user_id = current_user.id if current_user.id is not None else -1\n    metodo.data_validade = metodo.data_validade.replace(tzinfo=None)\n    pagamento = Pagamento(**metodo.model_dump())\n    return await create_item(session, Pagamento, pagamento.model_dump())\n')
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    from uvicorn import run
    
    from core.database import create_db_and_tables, init_astra_cassandra
    from routes import compras, payment_methods, products, token, user
    from schemas.payment_methods import PagamentoPublic  # type: ignore # noqa: F401
    from schemas.user import UserWithRelations
    from settings import SETTINGS
    
    UserWithRelations.model_rebuild()
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        await create_db_and_tables()
        await init_astra_cassandra()
    
        yield
    
    
    app = FastAPI(lifespan=lifespan)
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:3001", "http://127.0.0.1:3001"],
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allow_headers=["*"],
    )
    app.include_router(token.router)
    app.include_router(user.router)
    app.include_router(payment_methods.router)
    app.include_router(products.router)
    app.include_router(compras.router)
    
    
    if __name__ == "__main__":
        run(
            "main:app",
            host="0.0.0.0",
            reload=True,
            port=8000,
            ssl_certfile=SETTINGS.CERT_PEM,
            ssl_keyfile=SETTINGS.KEY_PEM,
        )
    